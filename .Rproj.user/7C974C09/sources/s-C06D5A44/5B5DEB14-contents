---
title: "dplyr Functions"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

### dplyr functions:

First, turn the data into a more informative and condensed format

```{r}
data <- tbl_df(original_data)
rm("original_data")
```

#### select()

Select and/or arrange specific columns to show from the data set


```{r}
select(data, column1, column3, column5)
select(data, column1:column5)
select(data, -(column1:column5))
```

#### filter()

Filter the data into a desired set of rows based on conditions

- The conditions return a vecture of T/F, filter only returns the rows that have all "T"s
- You can use any conditions applied to strings or numbers
- You can also use functions like `is.na()` to filter by NAs

```{r}
filter(data, column1 == "string", column2 <= int)
filter(data, column1 == "string" | column2 == "string")
filter(data, !is.na(column1))
```

#### arrange()

Arrange the rows of the table based on some column of values

- If there are rows that have the same value, the sort can be performed based on the next column argument
- 

```{r}
arrange(data, column1)
arrange(data, desc(column1))
arrange(data, column1, column2)
```

#### mutate()

Create a new variable based on the value of one or more columns

- Must save this column by making a new object or saving over the dataset.

```{r}
mutate(data, new_column = column1 / 20)
mutate(data, new_column = column1 / column2)
```

#### group_by()

Breaks up data into groups of rows based on the values of one or more variables.

- Printing the data frame tbl will mention the grouping but not show it
- Operations will be applied per group

```{r}
grouped_data <- group_by(data, variable)
summarise(grouped_data, mean(variable))
```

#### summarise()

Collapses the dataset to a single row

- Most useful when applying to data grouped by the values of a particular variable
        - Provides a single row for each group
- n() and n_distinct() both only used from within summarise
        - 

```{r}
summarize(by_package,
          count = n(),
          unique = n_distinct(ip_id),
          countries = n_distinct(country),
          avg_bytes = mean(size))
#summarize a number of values
quantile(pack_sum$count, probs = 0.99)#top 1% boundary

top_counts <- filter(pack_sum, count > 679)#packages in top 1%

View(top_counts)#bring up a tabular gui display

top_counts_sorted <- arrange(top_counts, desc(count))
```

#### Chaining

- String together multiple function calls in a single line
- `%>%`

```{r}
cran %>%
  select(ip_id, country, package, size) %>%
  mutate(size_mb = size / 2^20) %>%
  filter(size_mb <= 0.5) %>%
  arrange(desc(size_mb))